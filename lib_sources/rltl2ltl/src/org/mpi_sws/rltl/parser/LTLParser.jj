/*
 *  rLTL Tool Collection
 *  Copyright (C) 2017  Daniel Neider
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

options
{
  LOOKAHEAD= 2; // Set look-ahead to two tokens
  FORCE_LA_CHECK = true; // Forces a look-ahead check
  STATIC = false; // Do not make a static parser
}


PARSER_BEGIN(LTLParser)

package org.mpi_sws.rltl.parser;

import org.mpi_sws.rltl.expressions.*;
import org.mpi_sws.rltl.visitors.*;


/**
 * A parser for LTL expression.
 * <p>
 * This parser is auto generated by JavaCC.
 *
 * @author Daniel Neider
 *
 * @version 1.0
 */
public class LTLParser {
    
}

PARSER_END(LTLParser)

SKIP :
{
	" " | "\r" | "\t" | "\n"
}

TOKEN : /* OPERATORS */
{
 	< FOP : "F" >
|	< GOP : "G" >
|	< XOP : "X" >
|	< UOP : "U" >
|	< ROP : "R" >
|	< AND : "&" >
|	< OR : "|" >
|	< IMPL : "=>" >
|	< NEG : "!" >
|	< LPAR : "(" >
|	< RPAR : ")" >
}

TOKEN :
{
	< ID : ([ "A"-"Z" ] | [ "a"-"z" ]) ([ "0"-"9" ] | [ "A"-"Z" ] | [ "a"-"z" ])* >
}


Expression expression() :
{
	Expression expr = null;
}
{
	expr = implication() <EOF>
	{
		return expr;
	}
}

Expression implication() :
{
	Expression expr = null;
	Expression result = null;
}
{
	result = disjunction()

	(
		<IMPL> expr = disjunction()
		{
			result = new Implication(result, expr);
		}
	)*

	{
		return result;
	}
}

Expression disjunction() :
{
	Expression expr = null;
	Expression result = null;
}
{
	
	result = conjunction()

	(
		<OR> expr = conjunction()
		{
			result = new Disjunction(result, expr);
		}
	)*
	{
		return result;
	}
}

Expression conjunction() :
{
	Expression expr = null;
	Expression result = null;
}
{
	result = untilOp()

	(
		<AND> expr = untilOp()
		{
			result = new Conjunction(result, expr);
		}
	)*

	{
		return result;
	}
}

Expression untilOp() :
{
	Expression expr = null;
	Expression result = null;
}
{

	result = unaryOp()
	(
		<UOP> expr = unaryOp()
		{
			result = new Until(result, expr);
		}
		|
		<ROP> expr = unaryOp()
		{
			result = new Release(result, expr);
		}

	)*
	{
		return result;
	}

}

Expression unaryOp() :
{
	Expression expr = null;
}
{
	<FOP> expr = unaryOp()
	{
		return new Finally(expr);
	}

|	<GOP> expr = unaryOp()
	{
		return new Globally(expr);
	}

|	<XOP> expr = unaryOp()
	{
		return new Next(expr);
	}

|	<NEG> expr = unaryOp()
	{
		return new Negation(expr);
	}

|	expr = atom()
	{
		return expr;
	}
}

Expression atom() :
{
	Expression expr = null;
	String id = null;
}
{
	id = <ID>.image
	{
		return new Atom(id);
	}
|	<LPAR> expr = implication() <RPAR>
	{
		return expr;
	}
}

